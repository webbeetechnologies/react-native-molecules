"use strict";(self.webpackChunkmolecules_docs_v2=self.webpackChunkmolecules_docs_v2||[]).push([[1677],{6988:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"fast-context","title":"FastContext","description":"Performance-optimized context implementation using refs and selectors to minimize re-renders.","source":"@site/docs/fast-context.mdx","sourceDirName":".","slug":"/fast-context","permalink":"/react-native-molecules/docs/fast-context","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fast-context.mdx","tags":[],"version":"current","sidebarPosition":45,"frontMatter":{"title":"FastContext","description":"Performance-optimized context implementation using refs and selectors to minimize re-renders.","sidebar_position":45,"sidebar_custom_props":{"icon":"material:bolt"}},"sidebar":"componentSidebar","previous":{"title":"ShortcutsManager","permalink":"/react-native-molecules/docs/shortcuts-manager"},"next":{"title":"ContextBridge","permalink":"/react-native-molecules/docs/context-bridge"}}');var r=t(2540),o=t(3023);const i={title:"FastContext",description:"Performance-optimized context implementation using refs and selectors to minimize re-renders.",sidebar_position:45,sidebar_custom_props:{icon:"material:bolt"}},a="FastContext",c={},l=[{value:"Key Features",id:"key-features",level:2},{value:"API",id:"api",level:2},{value:"<code>createFastContext&lt;T&gt;(defaultValue?, watch?)</code>",id:"createfastcontexttdefaultvalue-watch",level:3},{value:"Examples",id:"examples",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Using useStoreRef (No Re-renders)",id:"using-usestoreref-no-re-renders",level:3},{value:"With Custom Equality Check",id:"with-custom-equality-check",level:3},{value:"Watch Mode",id:"watch-mode",level:3},{value:"Integration with ContextBridge",id:"integration-with-contextbridge",level:3},{value:"When to Use",id:"when-to-use",level:2},{value:"Benefits Over Traditional Context",id:"benefits-over-traditional-context",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"fastcontext",children:"FastContext"})}),"\n",(0,r.jsx)(n.p,{children:"FastContext is a performance-optimized context implementation that uses refs and subscriptions to avoid unnecessary re-renders. Unlike traditional React Context, FastContext allows you to subscribe to specific parts of the store using selectors, ensuring components only re-render when the selected data changes."}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selector-based subscriptions"}),": Only re-render when selected data changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ref-based store"}),": Access store values without causing re-renders using ",(0,r.jsx)(n.code,{children:"useStoreRef"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fine-grained updates"}),": Update specific parts of the store without affecting unrelated components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Equality checks"}),": Customizable equality functions for selector comparisons"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,r.jsx)(n.h3,{id:"createfastcontexttdefaultvalue-watch",children:(0,r.jsx)(n.code,{children:"createFastContext<T>(defaultValue?, watch?)"})}),"\n",(0,r.jsx)(n.p,{children:"Creates a new FastContext instance."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"defaultValue"})," (optional): Default value for the store"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"watch"})," (optional): If ",(0,r.jsx)(n.code,{children:"true"}),", the provider will watch for prop changes and update the store"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Provider"}),": Context provider component"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useContext"}),": Hook that returns ",(0,r.jsx)(n.code,{children:"[selectedValue, setter]"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useContextValue"}),": Hook that returns just the selected value"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useStoreRef"}),": Hook that returns the store ref (doesn't cause re-renders)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Context"}),": The underlying React context (useful for ContextBridge)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { createFastContext } from 'react-native-molecules/fast-context';\n\ntype Store = {\n    count: number;\n    name: string;\n};\n\nconst { Provider, useContext, useContextValue } = createFastContext<Store>({\n    count: 0,\n    name: 'Initial',\n});\n\n// In your component tree\nexport const App = () => {\n    return (\n        <Provider value={{ count: 0, name: 'John' }}>\n            <Counter />\n            <NameDisplay />\n        </Provider>\n    );\n};\n\n// Component that needs both value and setter\nconst Counter = () => {\n    const [count, setStore] = useContext(state => state.count);\n\n    return (\n        <View>\n            <Text>Count: {count}</Text>\n            <Button\n                onPress={() => setStore(prev => ({ count: prev.count + 1 }))}\n            >\n                Increment\n            </Button>\n        </View>\n    );\n};\n\n// Component that only needs the value\nconst NameDisplay = () => {\n    const name = useContextValue(state => state.name);\n\n    return <Text>Name: {name}</Text>;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-usestoreref-no-re-renders",children:"Using useStoreRef (No Re-renders)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const { Provider, useStoreRef } = createFastContext<Store>();\n\nconst NonRenderingComponent = () => {\n    const storeRef = useStoreRef();\n\n    const handleClick = () => {\n        // Access current value without causing re-render\n        const currentCount = storeRef.current.get().count;\n        console.log('Current count:', currentCount);\n    };\n\n    return <Button onPress={handleClick}>Log Count</Button>;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"with-custom-equality-check",children:"With Custom Equality Check"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const { Provider, useContext } = createFastContext<Store>();\n\nconst CustomEqualityComponent = () => {\n    // Only re-render if the user object reference changes\n    const [user, setStore] = useContext(\n        state => state.user,\n        (a, b) => a.id === b.id && a.name === b.name\n    );\n\n    return <Text>{user.name}</Text>;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"watch-mode",children:"Watch Mode"}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"watch"})," is enabled, the provider will automatically update the store when the ",(0,r.jsx)(n.code,{children:"value"})," prop changes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const { Provider } = createFastContext<Store>(null, true);\n\nexport const App = () => {\n    const [storeValue, setStoreValue] = useState({ count: 0, name: 'John' });\n\n    return (\n        <Provider value={storeValue}>\n            {/* Store will update when storeValue changes */}\n            <ChildComponent />\n        </Provider>\n    );\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"integration-with-contextbridge",children:"Integration with ContextBridge"}),"\n",(0,r.jsx)(n.p,{children:"FastContext can be used with ContextBridge to bridge contexts across render boundaries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const { Provider, Context } = createFastContext<Store>();\n\n// Register the context with a bridge\nregisterContextToBridge(Context);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large stores"}),": When you have a large context store and want to avoid unnecessary re-renders"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance-critical components"}),": Components that need to access context but shouldn't re-render frequently"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective subscriptions"}),": When different components need different parts of the same store"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complex state management"}),": When you need fine-grained control over when components update"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"benefits-over-traditional-context",children:"Benefits Over Traditional Context"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced re-renders"}),": Components only re-render when their selected data changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selector-based"}),": Fine-grained control over what triggers updates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ref access"}),": Access store values without causing re-renders"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better performance"}),": Especially beneficial for large applications with complex state"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);